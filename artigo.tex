% The LaTeX is in here!
\documentclass[12pt]{article}
\renewcommand{\baselinestretch}{1.5} 
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{parskip}
\usepackage{xcolor}
\usepackage{float}
\fontfamily{Arial}\selectfont
\renewcommand{\familydefault}{\sfdefault}
\usepackage{listings}
\newcommand{\code}[1]{\texttt{#1}}
\usepackage{hyperref}
\usepackage{listings}
\lstloadlanguages{Ruby}
\lstloadlanguages{Bash}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{lightgray},
  keywordstyle=\color{blue},
  backgroundcolor = \color{lightgray!10},
  basicstyle=\small,
}
\usepackage[utf8]{inputenc}
\setlength{\parindent}{4em}
\usepackage[english]{babel}
\usepackage{geometry}
  \geometry{
    a4paper,
    total={170mm,257mm},
    left=30mm,
    right=30mm,
    top=20mm,
  }
\graphicspath{ {images/} }

\begin{document}
    \begin{center}
    \includegraphics[scale=0.5]{unb}
    \par
    \vspace{15mm}
    \normalsize{Universidade de Brasília - UnB}\\
    \normalsize{Instituto de Exatas}\\
    \normalsize{Departamento de Ciência da Computação}\\
    \vspace{15mm}
    \normalsize{Rodrigo Chaves - 13/0132624}\\
    \normalsize{Gabriel Mesquita - 13/0009121}\\
    \vspace{15mm}
    \Huge{Test-driven Development}\\

    \vspace{60mm}
    \normalsize{Brasília - DF}\\
    \textnormal{2016}
  \end{center}

  \clearpage

  \begin{center}
    Gabriel Mesquita de Araujo\\
    Rodrigo de Araujo Chaves\\
    \vspace{30mm}
    \Huge{Test-driven Development}
    \vspace{30mm}
    \normalsize{}
    \begin{flushright}
      Dissertação sobre por que Test-driven development\\
      é pratica que melhora a qualidade\\
      final do software apresentanda à disciplina\\
      de Engenharia de Software da Universidade de Brasília.\\
    \end{flushright}
  \end{center}

  \clearpage

  \renewcommand*\contentsname{Sumário}

  \tableofcontents

  \clearpage

  \section{Introdução}

  Hoje, no Brasil, não há dados confiáveis sobre quantos reais são perdidos por
  software defeituosos, mas especialistas afirmam que 8 bilhões de reais é um
  valor bem próximo da realidade brasileira. Um exemplo que pode demonstrar o 
  prejuízo de um software mal fabricado pode causar foi a sonda espacial Mars 
  Climate Orbiter, perdida na atmosfera de Marte por errar a unidade em um
  cálculo, misturando as medidas de pés e metros.

  Apesar desses danos de falhas serem custosos quando o software é colocado em
  produção, essas falhas também podem causar dor de cabeça as desenvolvedores e
  todos os stakeholders envolvidos durante a fase de desenvolvimento.

  \section{O que é Test-driven Development}

  Test-driven development é uma prática de desenvolvimento de software que tem 
  sido usada esporádicamente por décadas. Com essa prática, um engenheiro de 
  software passa por ciclos entre escrever um teste de unidade que falha e 
  escrevendo a implementação do software para passar nesses testes. 
  Test-driven development tem recentemente ressurgindo como uma prática crítica 
  possibilitando metodologias de desenvolvimento ágil de software.

  Quando discutimos sobre TDD, é considerado um conjunto de tarefas requiridas 
  que podem ser implementadas em poucos dias ou menos. Na imagem 1, engenheiros 
  de software produzem código de produção através de rápidas interações como as 
  que seguem:

  \begin{enumerate}
    \item O primeiro passo é adicionar um teste simples o qual é suficiente 
    para a suíte de teste falhar.
    \item Depois executamos nossa suíte para confirmar que os testes realmente 
    estão falhando.
    \item Agora atualiza-se o código funcional afim de passar no novo teste.
    \item Executamos a suíte de teste para verificarmos se agora realmente 
    passamos no novo teste.
    \item Agora com o teste passando: são removidos as duplicações de código 
    afim de limpar o código.
  \end{enumerate}

  \begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{tdd}
    \caption{Fluxograma do TDD}
  \end{figure}

  \section{Automação de Testes}

  No desenvolvimento orientado à Testes, uma ferramenta muito imporantante são
  os frameworks de testes automatizados para a criação de objetos orientados
  a testes de unidade. 

  Em Ruby, por exemplo, o framework \code{RSpec} é comumente usado onde cada 
  Classe Pública tem um class correspondente 
  \code{RSpec.describe <NomeDaClasse>}. Para cada método público dessa classe, 
  é criado um teste \code{it " <NomeDoMétodo> "} onde o 
  contrato do método é testado. Além disso, outros 
  \code{it " <NomeDaFuncionalidade> "}
  são criados para validar o comportamento desse método com diferentes 
  parametros. A cada execução de um \code{it}, um método 
  \code{before} é chamado e esse é responsável por criar as variáveis de teste,
  criar a instância de \code{<NomeDaClasse>} que serão usadas em um ou mais 
  métodos. Além disso, pode-se criar contextos onde um conjunto mais especifico
  de testes pode ser executado dentro de uma \code{context} e definir variáveis
  para esse contexto.

  Uma prática comum dos framework de automação de testes é usar cores
  para expressar o resultados da suíte de testes. Caso algum teste não passe,
  a cor vermelha é usada para indicar a atenção do desenvolvedor. Caso todos os
  testes passem, usamos a cor verde para indicar os resultados dos testes. A 
  imagem a baixo demonstra de forma simplificada qual é o ritmo comum dentro do
  ciclo do Test-driven Development.

  \begin{figure}[H]
    \centering
    \includegraphics[scale=1.0]{tdd_micro}
    \caption{Colograma do TDD}
  \end{figure}

  \section{Um exemplo de TDD}

  Para demonstrar como fazemos TDD, iremos usar o framework RSpec em Ruby para
  criar uma calculadora. Iniciamos nossa calculadora criando nosso primeiro 
  teste:

  \begin{lstlisting}[language=Ruby]
  # Arquivo Calculator_rspec.rb

  RSpec.describe Calculator do
  end
  \end{lstlisting}

  Executando esse teste, teremos esse resultado. Para executar a suíte de teste
  do RSpec, chamamos o comando rspec no terminal:

  \begin{lstlisting}[language=bash]
  $ rspec
  uninitialized constant Calculator (NameError)
  \end{lstlisting}

  Com esse, identificamos que o próximo passo é criar a classe \code{Calculator}

  \begin{lstlisting}[language=Ruby]
  # Arquivo Calculator.rb

  class Calculator
  end
  \end{lstlisting}

  Executando a suíte de teste novamente.

  \begin{lstlisting}[language=bash]
  $ rspec
  No examples found.


  Finished in 0.00043 seconds 
  (files took 0.15324 seconds to load)
  0 examples, 0 failures
  \end{lstlisting}

  Passando pelo nosso primeiro teste, voltamos a escrever os testes. Vamos 
  escrever um teste que espera que nossa calculadora faça uma soma simples de 
  1 mais 2 e encontre o resultado 3.

  \begin{lstlisting}[language=Ruby]
  # Arquivo Calculator_rspec.rb

  RSpec.describe Calculator do
    describe "#add" do
      it "returns the sum of its arguments" do
        expect(Calculator.new.add(1,2)).to eq(3)
      end
    end
  end
  \end{lstlisting}

  Esse novo teste é descrito dentro de um bloco \code{add} onde todos os 
  compartamentos desse método são testados. Executando a suíte de testes
  novamente.

  \begin{lstlisting}[language=bash]
  $ rspec
  F

  Failures:

    1) Calculator#add returns the sum of its arguments 
       Failure/Error: expect(@calculator.add(1,2)).to eq(3)
       
       NoMethodError:
         undefined method `add' for nil:NilClass
       # ./spec/calculator_spec.rb:10:in `block (3 levels) 
       in <top (required)>'

  Finished in 0.00069 seconds (files took 0.15787 seconds 
  to load) 1 example, 1 failure

  Failed examples:

  rspec ./spec/calculator_spec.rb:9 # Calculator#add returns 
  the sum of its arguments 
  \end{lstlisting}
  
  Temos um novo erro. Agora temos um teste em vermelho, podemos codificar a
  nossa class \code{Calculator}. Vamos fazer um método que retorne a soma de
  dois parâmetros.

  \begin{lstlisting}[language=Ruby]
  # Arquivo Calculator.rb

  class Calculator
    def add a, b
      return a + b
    end
  end
  \end{lstlisting}

  Executa-se novamente a suíte de testes.

  \begin{lstlisting}[language=bash]
  $ rspec
  .

  Finished in 0.00158 seconds (files took 0.19148 seconds to 
  load)
  1 example, 0 failures
  \end{lstlisting}

  Agora iremos testar se o nosso método \code{add} consegue somar um número
  negativo.

  \begin{lstlisting}[language=Ruby]
  RSpec.describe Calculator do

    describe "#add" do
      it 'returns the sum of its arguments ' do
        expect(Calculator.new.add(1,2)).to eq(3)
      end

      it 'can calculate with negative param' do
        expect(Calculator.new.add(1, -2)).to eq(-1)
      end
    end
  end
  \end{lstlisting}

  Executando novamente a suíte de testes.

  \begin{lstlisting}[language=bash]
  $ rspec
  ..

  Finished in 0.00231 seconds (files took 0.18369 seconds to 
  load)
  2 examples, 0 failures
  \end{lstlisting}

  \section{Design de Software em TDD}

  O Test-driven Development permite que o desenvolvedor que está trabalhando 
  em um módulo pense como serão as responsabilidades, interfaces, serviços os 
  quais serão disponibilizados por esse módulo, enquanto escreve os testes. 
  Depois, quando vai escrever o código de produção, pode se preocupar somente em
  implementar o necessário para passar nos testes já feitos. Fazendo assim, 
  criamos um ritmo entre codificação e teste até que todos os testes criados 
  sejam implementados.

  Pensando no design do projeto, os desenvolvedores do projeto podem criar
  classes e módulos mais coesos e menos acopladas por que, durante a fase de 
  elaboração dos testes, conseguem visualizar a arquitetura geral da aplicação e
  melhorar como o componente que irão desenvolver conversa com os outros 
  componentes. Em alguns testes, os desenvolvedores os escrevem usando o 
  componente em desenvolvimento como já estivesse pronto e validam se
  esse consegue se comunicar com suas interfaces.

  Em Test-driven Development, o código desenvolvido é mantido dentro do controle
  intelectual do desenvolvedor, já que o próprio escreveu os testes e ele ou 
  ela está fazendo continuamente pequenas alterações de design e decisões de 
  implementação, aumentando as funcionalidades do programa em um certo ritmo 
  contínuo.

  \section{Desenvolvimento Ágil e Test-driven Development}

  Test-driven development é uma prática sugerida dentro do "Extremming 
  Programming", também muito conhecido por XP, por Kent Beck. XP é surgiu nos
  Estados Unidos e tem ganhado bastante espaço no desenvolvimento de software
  pois é um conjunto de valores, principios e práticas que fazem os softwares 
  serem produzidos em menos tempo e de forma mais econômica que o habitual.

  Desenvolvimento incremental é uma prática que não só traz benefícios. Ao se
  adicionar novas funcionalidade a um software, há um risco de falhas serem 
  introduzidas. O XP adotou o uso de Test-driven Development como um mecanismo
  de proteção impedindo que algo que já estivesse funcionando fosse quebrado
  e não detectado. “O desenvolvimento orientado a testes é uma forma de lidar 
  com o medo durante a programação (BECK, 2003).”

  Os testes automatizados criados pelos desenvolvedores formam uma base de 
  testes que pode ser executada sempre que necessário visualizar se tudo está
  funcionando normalmente. Isso não impede que falhas sejam inseridas, porém
  é uma forma de detecção possibilitando uma correção efetiva e barata, impedindo
  que bugs se acumulem com o passar do tempo.

  \section{Objetivos ao se praticar TDD}

  TDD é uma prática de desenvolvimento que tem por objetivo garantir a
  qualidade e a confiabilidade do produto o mais rápido possível. Ao decorrer do
  desenvolvimento, todo o código elaborado é desenvolvido em conjunto com uma
  suíte de testes automatizados. Esses testes permitem uma segurança maior ao
  desenvolvedor quando precisa mudar algo que já foi implementado ou precisa 
  refatorar o código.

  Além disso, desenvolvedores experientes em TDD podem analisar se os testes 
  produzidos estão difíceis de serem feitos e podem fazer refactoring ou 
  mudanças.

  \section{Depuração}

  Quando é detectado um defeito em um software, é necessário consertá-lo. Nesse
  momento, entramos na fase de depuração. Se observamos os programadores 
  realizando suas atividades, iremos perceber que eles levam mais tempo é 
  depurando. Ou seja, procurando por falhas.
  Uma pequena parte do tempo de desenvolvimento é usado para a 
  codificação propriamente dita. O 
  restante do tempo é gasto projetando-se e entendendo o que deve ser feito.

  Consertar a falha identificada é fácil, porém encontrar onde está acontecendo
  o problema é o que leva a fase de depuração ser tão longa. As equipes de 
  desenvolvimento podem usar o Test-driven Development para serem capazes de
  identificar mais rapidamente essas falhas.

  Além disso, ao se consertar uma falha local, existe uma possibilidade (entre
  20 a 50 por cento) de se introduzir uma nova falha. As bases de testes 
  automatizados facilitam a garantir que as correções feitas não introduzem 
  novos problemas pois conseguem testar as outras funcionalidades do sistema
  ao ser executada.

  \section{Conclusão}

  Em vista dos fatos mencionados, é possível observar que o test-driven development 
  sem dúvida auxilia o processo de desenvolvimento de software de diversas
  maneiras. Essa prática melhora a qualidade do software como já foi discutido
  e se utilizado corretamente diminui custos relacionados a correção de bugs 
  ou refactoring de códigos complexos, boiler-plate e etc.

  É de extrema importância mencionar que o TDD é uma prática útil, porém nem 
  sempre é a melhor solução para um determinado problema. O contexto da empresa, 
  do sistema e dos stakeholders devem ser analisados para avaliar se o TDD vai 
  ser útil ou não. Ou seja, a falta desse tipo de análise pode gerar custos 
  desnecessários ao desenvolvimento tanto monétarios quanto relacionados ao 
  tempo de desenvolvimento.
  \clearpage

  \section{Referências}

  \begin{flushleft}
  Nachiappan Nagappan, E. Michael Maximilien, Thirumalesh Bhat,
  Laurie Williams, Realizing quality improvement through test driven 
  development: results and experiences of four industrial teams. Disponível em
  \url{http://link.springer.com/article/10.1007/s10664-008-9062-z#/page-1}.
  Acessado em 26 de maio de 2016.

  Andreas Augustin, Test-Driven Development: Concepts, Taxonomy, and Future 
  Direction. Disponível em \url{https://www.semanticscholar.org/paper/Test-
  Driven-Development-Concepts-Taxonomy-and-Janzen-Saiedian/bdcd570eb6a45d7a
  9107a18e25f54b741b92177f/pdf}. Acessado em 26 de maio de 2016

  Martin Fowler, Bill Venners: Test-Driven Development, A Conversation with 
  Martin Fowler. Disponível em \url{http://www.biology.emory.edu/research/Prinz
  /Cengiz/cs540-485-FA12/resources/testDrivenDev.pdf}. Acessado em 30 de maio de
  2016.

  Mauricio Finavaro Aniche, Como a prática de TDD influencia o projeto de 
  classes em sistemas orientados a objetos. Disponível em 
  \url{http://www.teses.usp.br/teses/disponiveis/45/45134/tde-31072012-181230
  /publico/dissertacao.pdf}. Acessado em 30 de maio de 2016.

  Roger Pressman, Software Engineering: A Practitioner’s Approach, 7/e 
  (McGraw-Hill, 2009), capítulo 3.  Disponível em
  \url{http://academic.brooklyn.cuny.edu/cis/sfleisher/Chapter_03_sim.pdf}.
  Acessado em 1º de junho de 2016.

  Vínicius Manhães Teles, Um estudo de caso da adoção das práticas e valores do
  extremme programming. Disponível em
  \url{http://www.improveit.com.br/xp/dissertacaoXP.pdf}. Acessado em 1º de 
  junho de 2016.

  Laurie Williams, E. Michael Maximilien, Mladen Vouk, Test-Driven Development 
  as a Defect-Reduction Practice. Disponível em 
  \url{ftp://www.ufv.br/dpi/mestrado/TDD
  /willians_TDD_Defect-Reducion_Practice.pdf}. Acessado em 1º de Junho de 2016.

  André Faria Gomes, Agile, Desenvolvimento de Software com entregas frequentes
  e foco no valor de negócio. Casa do Código.
  
  \end{flushleft}

\end{document}